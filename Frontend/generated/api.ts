/* tslint:disable */
/* eslint-disable */
/**
 * 인천대학교 공지사항 API
 * 인천대학교 공지사항 앱 백엔드 API 문서
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ApiResponseBoolean {
    'success'?: boolean;
    'message'?: string;
    'data'?: boolean;
    'timestamp'?: string;
}
export interface ApiResponseDetailResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: DetailResponse;
    'timestamp'?: string;
}
export interface ApiResponseFindIdResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: FindIdResponse;
    'timestamp'?: string;
}
export interface ApiResponseListAutocompleteSuggestion {
    'success'?: boolean;
    'message'?: string;
    'data'?: Array<AutocompleteSuggestion>;
    'timestamp'?: string;
}
export interface ApiResponseListPopularKeyword {
    'success'?: boolean;
    'message'?: string;
    'data'?: Array<PopularKeyword>;
    'timestamp'?: string;
}
export interface ApiResponseListResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: Array<Response>;
    'timestamp'?: string;
}
export interface ApiResponseLoginResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: LoginResponse;
    'timestamp'?: string;
}
export interface ApiResponseLong {
    'success'?: boolean;
    'message'?: string;
    'data'?: number;
    'timestamp'?: string;
}
export interface ApiResponsePageResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: PageResponse;
    'timestamp'?: string;
}
export interface ApiResponseResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: Response;
    'timestamp'?: string;
}
export interface ApiResponseSearchResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: SearchResponse;
    'timestamp'?: string;
}
export interface ApiResponseString {
    'success'?: boolean;
    'message'?: string;
    'data'?: string;
    'timestamp'?: string;
}
export interface ApiResponseUserResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: UserResponse;
    'timestamp'?: string;
}
export interface ApiResponseVoid {
    'success'?: boolean;
    'message'?: string;
    'data'?: object;
    'timestamp'?: string;
}
export interface ApiResponseWebhookResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: WebhookResponse;
    'timestamp'?: string;
}
export interface AutocompleteSuggestion {
    'keyword'?: string;
    'matchCount'?: number;
    'category'?: string;
}
export interface ChangePasswordRequest {
    'currentPassword': string;
    'newPassword': string;
    'confirmPassword': string;
}
export interface CreateRequest {
    'noticeId'?: number;
    'memo'?: string;
}
export interface DeleteAccountRequest {
    'password': string;
}
export interface DetailResponse {
    'id'?: number;
    'title'?: string;
    'content'?: string;
    'url'?: string;
    'externalId'?: string;
    'categoryId'?: number;
    'category'?: Response;
    'source'?: string;
    'author'?: string;
    'publishedAt'?: string;
    'viewCount'?: number;
    'isImportant'?: boolean;
    'isPinned'?: boolean;
    'attachments'?: string;
    'bookmarked'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface EmailLoginRequest {
    'email': string;
    'password': string;
    'fcmToken'?: string;
}
export interface FindIdRequest {
    'name': string;
    'studentId': string;
}
export interface FindIdResponse {
    'maskedEmail'?: string;
    'message'?: string;
}
export interface ForgotPasswordRequest {
    'email': string;
}
export interface LoginRequest {
    'idToken': string;
    'fcmToken'?: string;
}
export interface LoginResponse {
    'idToken'?: string;
    'tokenType'?: string;
    'expiresIn'?: number;
    'user'?: UserResponse;
}
export interface NewNoticeWebhookRequest {
    'noticeId'?: number;
    'title'?: string;
    'broadcast'?: boolean;
}
export interface PageResponse {
    'totalPages'?: number;
    'totalElements'?: number;
    'first'?: boolean;
    'size'?: number;
    'content'?: Array<Response>;
    'number'?: number;
    'sort'?: SortObject;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageableObject {
    'offset'?: number;
    'sort'?: SortObject;
    'pageNumber'?: number;
    'pageSize'?: number;
    'paged'?: boolean;
    'unpaged'?: boolean;
}
export interface PopularKeyword {
    'keyword'?: string;
    'searchCount'?: number;
    'rank'?: number;
}
export interface Response {
    'id'?: number;
    'studentId'?: string;
    'email'?: string;
    'name'?: string;
    'role'?: string;
    'isActive'?: boolean;
    'darkMode'?: boolean;
    'systemNotificationEnabled'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface SaveRequest {
    'keyword'?: string;
}
export interface SearchResponse {
    'results'?: Array<SearchResult>;
    'keyword'?: string;
    'totalCount'?: number;
    'currentPage'?: number;
    'pageSize'?: number;
    'totalPages'?: number;
    'hasNext'?: boolean;
    'hasPrevious'?: boolean;
    'searchTimeMs'?: number;
}
export interface SearchResult {
    'id'?: number;
    'title'?: string;
    'contentPreview'?: string;
    'url'?: string;
    'categoryId'?: number;
    'categoryName'?: string;
    'source'?: string;
    'author'?: string;
    'publishedAt'?: string;
    'viewCount'?: number;
    'isImportant'?: boolean;
    'bookmarked'?: boolean;
    'relevanceScore'?: number;
}
export interface SignUpRequest {
    'studentId': string;
    'email': string;
    'password': string;
    'name': string;
}
export interface SortObject {
    'empty'?: boolean;
    'sorted'?: boolean;
    'unsorted'?: boolean;
}
export interface SubscribeRequest {
    'categoryId': number;
    'notificationEnabled'?: boolean;
}
export interface UpdateFcmTokenRequest {
    'fcmToken': string;
}
export interface UpdateNotificationRequest {
    'notificationEnabled': boolean;
}
export interface UpdateProfileRequest {
    'name': string;
    'email'?: string;
}
export interface UpdateRequest {
    'memo'?: string;
}
export interface UpdateSettingsRequest {
    'darkMode'?: boolean;
    'systemNotificationEnabled'?: boolean;
}
export interface UserResponse {
    'id'?: number;
    'studentId'?: string;
    'email'?: string;
    'name'?: string;
    'role'?: string;
}
export interface WebhookResponse {
    'noticeId'?: number;
    'title'?: string;
    'notificationsSent'?: number;
    'message'?: string;
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 입력 중인 검색어에 대한 자동완성 제안을 제공합니다.  - 최소 2글자 이상 입력 필요 - 접두사 매칭 (prefix matching) - 매칭된 공지사항 수와 함께 반환 
         * @summary 검색어 자동완성
         * @param {string} prefix 검색어 접두사 (최소 2글자)
         * @param {number} [limit] 결과 개수 제한
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocomplete: async (prefix: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('autocomplete', 'prefix', prefix)
            const localVarPath = `/api/search/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
         * @summary 비밀번호 변경
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/api/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
         * @summary 북마크 생성
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark: async (createRequest: CreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRequest' is not null or undefined
            assertParamExists('createBookmark', 'createRequest', createRequest)
            const localVarPath = `/api/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
         * @summary 회원 탈퇴
         * @param {DeleteAccountRequest} deleteAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (deleteAccountRequest: DeleteAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAccountRequest' is not null or undefined
            assertParamExists('deleteAccount', 'deleteAccountRequest', deleteAccountRequest)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자의 모든 최근 검색어를 삭제합니다.
         * @summary 모든 최근 검색어 삭제
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllRecentSearches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 저장한 북마크를 삭제합니다.
         * @summary 북마크 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBookmark', 'id', id)
            const localVarPath = `/api/bookmarks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 최근 검색어를 삭제합니다.
         * @summary 최근 검색어 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecentSearch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRecentSearch', 'id', id)
            const localVarPath = `/api/search/recent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
         * @summary 아이디 찾기
         * @param {FindIdRequest} findIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findId: async (findIdRequest: FindIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findIdRequest' is not null or undefined
            assertParamExists('findId', 'findIdRequest', findIdRequest)
            const localVarPath = `/api/auth/find-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 비밀번호를 잊어버린 사용자에게 재설정 이메일을 발송합니다.  **Firebase 기반:** - Firebase Admin SDK로 비밀번호 재설정 링크 생성 - 이메일로 재설정 링크 발송 - 사용자는 링크를 클릭하여 새 비밀번호 설정  **사용 방법:** 1. 이메일 입력하여 요청 2. 이메일로 재설정 링크 수신 3. 링크 클릭하여 새 비밀번호 입력 4. Firebase에서 자동으로 비밀번호 업데이트  **제한:** - 동일 이메일로 1시간에 최대 3회까지 요청 가능 
         * @summary 비밀번호 재설정 요청
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordRequest: ForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordRequest' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordRequest', forgotPasswordRequest)
            const localVarPath = `/api/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 활성 상태인 카테고리만 조회합니다.
         * @summary 활성 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 알림이 활성화된 구독 카테고리만 조회합니다.
         * @summary 활성 구독 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/preferences/categories/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
         * @summary 전체 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 북마크의 상세 정보를 조회합니다.
         * @summary 북마크 상세 조회
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBookmark', 'id', id)
            const localVarPath = `/api/bookmarks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 저장한 북마크의 총 개수를 조회합니다.
         * @summary 북마크 개수 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarks/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
         * @summary 특정 카테고리 조회
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryByCode: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getCategoryByCode', 'code', code)
            const localVarPath = `/api/categories/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 중요 표시된 공지사항 목록을 조회합니다.
         * @summary 중요 공지사항 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportantNotices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notices/important`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
         * @summary 북마크 목록 조회
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyBookmarks: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 현재 로그인한 사용자의 정보를 조회합니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 구독한 모든 카테고리 목록을 조회합니다.
         * @summary 구독 카테고리 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/preferences/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 공지사항의 상세 정보를 조회합니다. 조회 시 조회수가 1 증가합니다.
         * @summary 공지사항 상세 조회
         * @param {number} noticeId 공지사항 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeDetail: async (noticeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeId' is not null or undefined
            assertParamExists('getNoticeDetail', 'noticeId', noticeId)
            const localVarPath = `/api/notices/{noticeId}`
                .replace(`{${"noticeId"}}`, encodeURIComponent(String(noticeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 공지사항 목록을 페이징하여 조회합니다. 카테고리, 중요 공지 필터링과 정렬 옵션을 제공합니다.
         * @summary 공지사항 목록 조회
         * @param {number} [categoryId] 카테고리 ID (선택사항)
         * @param {string} [sortBy] 정렬 방식 (latest: 최신순, oldest: 오래된순, popular: 인기순)
         * @param {boolean} [important] 중요 공지만 조회 여부
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지 크기
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotices: async (categoryId?: number, sortBy?: string, important?: boolean, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (important !== undefined) {
                localVarQueryParameter['important'] = important;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 최근 24시간 기준 인기 검색어 TOP N을 조회합니다.  **Note:** 현재는 구현되지 않았습니다. search_log 테이블 추가 후 활성화됩니다. 
         * @summary 인기 검색어 조회
         * @param {number} [limit] 조회할 인기 검색어 개수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularKeywords: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search/popular`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
         * @summary 최근 검색어 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentSearches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 공지사항과 같은 카테고리의 다른 공지사항을 조회합니다.
         * @summary 관련 공지사항 조회
         * @param {number} noticeId 기준 공지사항 ID
         * @param {number} [limit] 조회할 관련 공지사항 개수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedNotices: async (noticeId: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeId' is not null or undefined
            assertParamExists('getRelatedNotices', 'noticeId', noticeId)
            const localVarPath = `/api/notices/{noticeId}/related`
                .replace(`{${"noticeId"}}`, encodeURIComponent(String(noticeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 크롤러 서버에서 새 공지사항 등록 시 호출됩니다.  **동작 과정:** 1. 크롤러가 새 공지사항 발견 및 DB 저장 2. 이 웹훅 호출 (POST /api/webhook/new-notice) 3. 키워드 매칭 검사 4. 매칭된 사용자들에게 FCM 푸시 알림 발송  **보안:** - API Key 인증 필요 (X-API-Key 헤더) - 크롤러 서버만 호출 가능  **제한:** - Rate limit: 1000 requests/hour 
         * @summary 새 공지사항 등록 웹훅
         * @param {NewNoticeWebhookRequest} newNoticeWebhookRequest 
         * @param {string} [xAPIKey] 크롤러 API Key (헤더)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNewNotice: async (newNoticeWebhookRequest: NewNoticeWebhookRequest, xAPIKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newNoticeWebhookRequest' is not null or undefined
            assertParamExists('handleNewNotice', 'newNoticeWebhookRequest', newNoticeWebhookRequest)
            const localVarPath = `/api/webhook/new-notice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAPIKey != null) {
                localVarHeaderParameter['X-API-Key'] = String(xAPIKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newNoticeWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 웹훅 서비스 상태 확인
         * @summary 웹훅 헬스체크
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 공지사항이 북마크되어 있는지 확인합니다.
         * @summary 북마크 여부 확인
         * @param {number} noticeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isBookmarked: async (noticeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeId' is not null or undefined
            assertParamExists('isBookmarked', 'noticeId', noticeId)
            const localVarPath = `/api/bookmarks/check/{noticeId}`
                .replace(`{${"noticeId"}}`, encodeURIComponent(String(noticeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 카테고리를 구독하고 있는지 확인합니다.
         * @summary 구독 여부 확인
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isSubscribed: async (categoryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('isSubscribed', 'categoryId', categoryId)
            const localVarPath = `/api/preferences/categories/{categoryId}/subscribed`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Firebase ID Token을 사용하여 로그인합니다.  **사용 방법:** 1. 클라이언트에서 Firebase SDK로 로그인    - 이메일/비밀번호: `signInWithEmailAndPassword(email, password)`    - Google: `signInWithPopup(googleProvider)`    - 기타 소셜 로그인 2. Firebase ID Token 발급: `user.getIdToken()` 3. 이 API에 ID Token 전송 4. 서버에서 토큰 검증 및 사용자 정보 동기화  **자동 회원가입:** Firebase로 로그인한 사용자가 서버 DB에 없는 경우, 자동으로 사용자가 생성됩니다.  **토큰 갱신:** Firebase SDK가 자동으로 처리합니다. `user.getIdToken(true)`를 호출하세요. 
         * @summary 로그인 (Firebase Authentication)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일과 비밀번호로 간편하게 로그인합니다.  **사용법:** ```bash POST /api/auth/login/email {   \"email\": \"test@inu.ac.kr\",   \"password\": \"password123\",   \"fcmToken\": \"dW4f2...\" (선택사항) } ```  **응답:** ```json {   \"success\": true,   \"data\": {     \"idToken\": \"eyJhbGc...\",  // Firebase 커스텀 토큰     \"tokenType\": \"Bearer\",     \"expiresIn\": 3600,     \"user\": {       \"id\": 1,       \"email\": \"test@inu.ac.kr\",       \"name\": \"홍길동\"     }   } } ```  **주의:** - ✅ 회원가입 직후 바로 사용 가능 - ✅ Firebase SDK 없이도 로그인 가능 - ⚠️ idToken(커스텀 토큰)은 Firebase 로그인 시에만 사용 - 💡 API 인증에는 이 토큰을 그대로 사용하세요  **클라이언트 사용 예시:** ```javascript const response = await fetch(\'/api/auth/login/email\', {   method: \'POST\',   headers: { \'Content-Type\': \'application/json\' },   body: JSON.stringify({     email: \'test@inu.ac.kr\',     password: \'password123\'   }) });  const { idToken, user } = await response.json();  // API 요청 시 토큰 사용 fetch(\'/api/notices\', {   headers: { \'Authorization\': `Bearer ${idToken}` } }); ``` 
         * @summary 이메일/비밀번호 로그인 (간편)
         * @param {EmailLoginRequest} emailLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithEmail: async (emailLoginRequest: EmailLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailLoginRequest' is not null or undefined
            assertParamExists('loginWithEmail', 'emailLoginRequest', emailLoginRequest)
            const localVarPath = `/api/auth/login/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그아웃 처리를 합니다. Firebase SDK에서 auth().signOut()을 호출하세요.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Firebase 이메일 인증 메일을 재발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript const user = auth().currentUser; await user.sendEmailVerification(); ```  이미 발송된 인증 메일을 받지 못한 경우 재발송합니다. 
         * @summary 이메일 인증 메일 재발송 (Firebase)
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('resendVerificationEmail', 'email', email)
            const localVarPath = `/api/auth/resend-verification-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
         * @summary 최근 검색어 저장
         * @param {SaveRequest} saveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRecentSearch: async (saveRequest: SaveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveRequest' is not null or undefined
            assertParamExists('saveRecentSearch', 'saveRequest', saveRequest)
            const localVarPath = `/api/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PostgreSQL Full-Text Search를 사용한 고속 검색 기능입니다.  **검색 기능:** - 제목 및 내용에서 키워드 검색 - 여러 단어 입력 시 OR 검색 (예: \"장학금 학사\" → 장학금 OR 학사) - 검색어 하이라이트 (<mark> 태그) - 관련도 점수 기반 정렬 (ts_rank)  **정렬 옵션:** - relevance: 관련도순 (기본값) - 검색어와 가장 관련있는 순서 - latest: 최신순 - 게시일 기준 최신 - oldest: 오래된순 - 게시일 기준 오래된  **성능:** - GIN 인덱스 사용으로 LIKE 검색 대비 10-100배 빠름 - 10,000건 기준: LIKE 200ms vs FTS 5ms 
         * @summary 공지사항 전문 검색
         * @param {string} keyword 검색 키워드 (필수)
         * @param {number} [categoryId] 카테고리 ID 필터 (선택사항)
         * @param {string} [sortBy] 정렬 방식 (relevance, latest, oldest)
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지 크기
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (keyword: string, categoryId?: number, sortBy?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('search', 'keyword', keyword)
            const localVarPath = `/api/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Firebase 이메일 인증 링크를 생성하여 발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript // React Native await user.sendEmailVerification();  // React Web import { sendEmailVerification } from \'firebase/auth\'; await sendEmailVerification(user); ```  **이 API 사용 시:** - 서버에서 커스텀 이메일 템플릿 사용 가능 - 이메일 발송을 서버에서 완전히 제어  Firebase 회원가입 후 이메일이 인증되지 않은 사용자에게 인증 메일을 발송합니다. 
         * @summary 이메일 인증 메일 발송 (Firebase)
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('sendVerificationEmail', 'email', email)
            const localVarPath = `/api/auth/send-verification-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 서버에서 Firebase Authentication에 사용자를 생성하고 DB에 저장합니다.  **플로우:** 1. **회원가입 API 호출** (이 엔드포인트)    - 서버: Firebase에 사용자 생성 + DB 저장    - 서버: 이메일 인증 링크 발송  2. **클라이언트: Firebase 로그인**    ```javascript    // React Native 예시    import auth from \'@react-native-firebase/auth\';     const userCredential = await auth().signInWithEmailAndPassword(email, password);    const idToken = await userCredential.user.getIdToken();    ```  3. **클라이언트: FCM 토큰 발급**    ```javascript    import messaging from \'@react-native-firebase/messaging\';     const fcmToken = await messaging().getToken();    ```  4. **로그인 API 호출** (`POST /api/auth/login`)    ```json    {      \"idToken\": \"eyJhbGc...\",      \"fcmToken\": \"dW4f2...\"    }    ```  **중요:** - ⚠️ idToken과 fcmToken은 서버에서 발급할 수 없습니다 - ⚠️ 회원가입 후 반드시 위 2-4 단계를 진행해야 합니다 - 이메일 인증은 선택사항 (인증 전에도 로그인 가능)  **대안 방법 (클라이언트 우선):** 1. 클라이언트: Firebase SDK로 직접 회원가입 `createUserWithEmailAndPassword()` 2. 클라이언트: ID Token 발급 3. 서버: `/api/auth/login` 호출 시 자동으로 DB에 사용자 생성 
         * @summary 회원가입 (Firebase 통합)
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUpRequest: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            assertParamExists('signUp', 'signUpRequest', signUpRequest)
            const localVarPath = `/api/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
         * @summary 카테고리 구독
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCategory: async (subscribeRequest: SubscribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequest' is not null or undefined
            assertParamExists('subscribeCategory', 'subscribeRequest', subscribeRequest)
            const localVarPath = `/api/preferences/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 카테고리 구독을 취소합니다.
         * @summary 구독 취소
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeCategory: async (categoryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('unsubscribeCategory', 'categoryId', categoryId)
            const localVarPath = `/api/preferences/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 저장한 북마크의 메모를 수정합니다.
         * @summary 북마크 메모 수정
         * @param {number} id 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkMemo: async (id: number, updateRequest: UpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBookmarkMemo', 'id', id)
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('updateBookmarkMemo', 'updateRequest', updateRequest)
            const localVarPath = `/api/bookmarks/{id}/memo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
         * @summary FCM 토큰 업데이트
         * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFcmToken: async (updateFcmTokenRequest: UpdateFcmTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateFcmTokenRequest' is not null or undefined
            assertParamExists('updateFcmToken', 'updateFcmTokenRequest', updateFcmTokenRequest)
            const localVarPath = `/api/users/fcm-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFcmTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
         * @summary 알림 설정 변경
         * @param {number} categoryId 
         * @param {UpdateNotificationRequest} updateNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateNotification', 'categoryId', categoryId)
            // verify required parameter 'updateNotificationRequest' is not null or undefined
            assertParamExists('updateNotification', 'updateNotificationRequest', updateNotificationRequest)
            const localVarPath = `/api/preferences/categories/{categoryId}/notification`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자의 이름 등 프로필 정보를 수정합니다.
         * @summary 프로필 수정
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (updateProfileRequest: UpdateProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileRequest' is not null or undefined
            assertParamExists('updateProfile', 'updateProfileRequest', updateProfileRequest)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
         * @summary 사용자 설정 수정
         * @param {UpdateSettingsRequest} updateSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings: async (updateSettingsRequest: UpdateSettingsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSettingsRequest' is not null or undefined
            assertParamExists('updateSettings', 'updateSettingsRequest', updateSettingsRequest)
            const localVarPath = `/api/users/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 입력 중인 검색어에 대한 자동완성 제안을 제공합니다.  - 최소 2글자 이상 입력 필요 - 접두사 매칭 (prefix matching) - 매칭된 공지사항 수와 함께 반환 
         * @summary 검색어 자동완성
         * @param {string} prefix 검색어 접두사 (최소 2글자)
         * @param {number} [limit] 결과 개수 제한
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocomplete(prefix: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListAutocompleteSuggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocomplete(prefix, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.autocomplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
         * @summary 비밀번호 변경
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
         * @summary 북마크 생성
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmark(createRequest: CreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmark(createRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
         * @summary 회원 탈퇴
         * @param {DeleteAccountRequest} deleteAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(deleteAccountRequest: DeleteAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(deleteAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자의 모든 최근 검색어를 삭제합니다.
         * @summary 모든 최근 검색어 삭제
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllRecentSearches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllRecentSearches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAllRecentSearches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 저장한 북마크를 삭제합니다.
         * @summary 북마크 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 최근 검색어를 삭제합니다.
         * @summary 최근 검색어 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecentSearch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecentSearch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteRecentSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
         * @summary 아이디 찾기
         * @param {FindIdRequest} findIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findId(findIdRequest: FindIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseFindIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findId(findIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 비밀번호를 잊어버린 사용자에게 재설정 이메일을 발송합니다.  **Firebase 기반:** - Firebase Admin SDK로 비밀번호 재설정 링크 생성 - 이메일로 재설정 링크 발송 - 사용자는 링크를 클릭하여 새 비밀번호 설정  **사용 방법:** 1. 이메일 입력하여 요청 2. 이메일로 재설정 링크 수신 3. 링크 클릭하여 새 비밀번호 입력 4. Firebase에서 자동으로 비밀번호 업데이트  **제한:** - 동일 이메일로 1시간에 최대 3회까지 요청 가능 
         * @summary 비밀번호 재설정 요청
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 활성 상태인 카테고리만 조회합니다.
         * @summary 활성 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getActiveCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 알림이 활성화된 구독 카테고리만 조회합니다.
         * @summary 활성 구독 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivePreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivePreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getActivePreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
         * @summary 전체 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 북마크의 상세 정보를 조회합니다.
         * @summary 북마크 상세 조회
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내가 저장한 북마크의 총 개수를 조회합니다.
         * @summary 북마크 개수 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarkCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarkCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBookmarkCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
         * @summary 특정 카테고리 조회
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryByCode(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryByCode(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCategoryByCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 중요 표시된 공지사항 목록을 조회합니다.
         * @summary 중요 공지사항 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportantNotices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportantNotices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getImportantNotices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
         * @summary 북마크 목록 조회
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyBookmarks(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponsePageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyBookmarks(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyBookmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 현재 로그인한 사용자의 정보를 조회합니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내가 구독한 모든 카테고리 목록을 조회합니다.
         * @summary 구독 카테고리 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyPreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyPreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 공지사항의 상세 정보를 조회합니다. 조회 시 조회수가 1 증가합니다.
         * @summary 공지사항 상세 조회
         * @param {number} noticeId 공지사항 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNoticeDetail(noticeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNoticeDetail(noticeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getNoticeDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 공지사항 목록을 페이징하여 조회합니다. 카테고리, 중요 공지 필터링과 정렬 옵션을 제공합니다.
         * @summary 공지사항 목록 조회
         * @param {number} [categoryId] 카테고리 ID (선택사항)
         * @param {string} [sortBy] 정렬 방식 (latest: 최신순, oldest: 오래된순, popular: 인기순)
         * @param {boolean} [important] 중요 공지만 조회 여부
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지 크기
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotices(categoryId?: number, sortBy?: string, important?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponsePageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotices(categoryId, sortBy, important, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getNotices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 최근 24시간 기준 인기 검색어 TOP N을 조회합니다.  **Note:** 현재는 구현되지 않았습니다. search_log 테이블 추가 후 활성화됩니다. 
         * @summary 인기 검색어 조회
         * @param {number} [limit] 조회할 인기 검색어 개수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopularKeywords(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListPopularKeyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopularKeywords(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getPopularKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
         * @summary 최근 검색어 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentSearches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentSearches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRecentSearches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 공지사항과 같은 카테고리의 다른 공지사항을 조회합니다.
         * @summary 관련 공지사항 조회
         * @param {number} noticeId 기준 공지사항 ID
         * @param {number} [limit] 조회할 관련 공지사항 개수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedNotices(noticeId: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedNotices(noticeId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRelatedNotices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 크롤러 서버에서 새 공지사항 등록 시 호출됩니다.  **동작 과정:** 1. 크롤러가 새 공지사항 발견 및 DB 저장 2. 이 웹훅 호출 (POST /api/webhook/new-notice) 3. 키워드 매칭 검사 4. 매칭된 사용자들에게 FCM 푸시 알림 발송  **보안:** - API Key 인증 필요 (X-API-Key 헤더) - 크롤러 서버만 호출 가능  **제한:** - Rate limit: 1000 requests/hour 
         * @summary 새 공지사항 등록 웹훅
         * @param {NewNoticeWebhookRequest} newNoticeWebhookRequest 
         * @param {string} [xAPIKey] 크롤러 API Key (헤더)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleNewNotice(newNoticeWebhookRequest: NewNoticeWebhookRequest, xAPIKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleNewNotice(newNoticeWebhookRequest, xAPIKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.handleNewNotice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 웹훅 서비스 상태 확인
         * @summary 웹훅 헬스체크
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.health']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 공지사항이 북마크되어 있는지 확인합니다.
         * @summary 북마크 여부 확인
         * @param {number} noticeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isBookmarked(noticeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isBookmarked(noticeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.isBookmarked']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 카테고리를 구독하고 있는지 확인합니다.
         * @summary 구독 여부 확인
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isSubscribed(categoryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isSubscribed(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.isSubscribed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Firebase ID Token을 사용하여 로그인합니다.  **사용 방법:** 1. 클라이언트에서 Firebase SDK로 로그인    - 이메일/비밀번호: `signInWithEmailAndPassword(email, password)`    - Google: `signInWithPopup(googleProvider)`    - 기타 소셜 로그인 2. Firebase ID Token 발급: `user.getIdToken()` 3. 이 API에 ID Token 전송 4. 서버에서 토큰 검증 및 사용자 정보 동기화  **자동 회원가입:** Firebase로 로그인한 사용자가 서버 DB에 없는 경우, 자동으로 사용자가 생성됩니다.  **토큰 갱신:** Firebase SDK가 자동으로 처리합니다. `user.getIdToken(true)`를 호출하세요. 
         * @summary 로그인 (Firebase Authentication)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일과 비밀번호로 간편하게 로그인합니다.  **사용법:** ```bash POST /api/auth/login/email {   \"email\": \"test@inu.ac.kr\",   \"password\": \"password123\",   \"fcmToken\": \"dW4f2...\" (선택사항) } ```  **응답:** ```json {   \"success\": true,   \"data\": {     \"idToken\": \"eyJhbGc...\",  // Firebase 커스텀 토큰     \"tokenType\": \"Bearer\",     \"expiresIn\": 3600,     \"user\": {       \"id\": 1,       \"email\": \"test@inu.ac.kr\",       \"name\": \"홍길동\"     }   } } ```  **주의:** - ✅ 회원가입 직후 바로 사용 가능 - ✅ Firebase SDK 없이도 로그인 가능 - ⚠️ idToken(커스텀 토큰)은 Firebase 로그인 시에만 사용 - 💡 API 인증에는 이 토큰을 그대로 사용하세요  **클라이언트 사용 예시:** ```javascript const response = await fetch(\'/api/auth/login/email\', {   method: \'POST\',   headers: { \'Content-Type\': \'application/json\' },   body: JSON.stringify({     email: \'test@inu.ac.kr\',     password: \'password123\'   }) });  const { idToken, user } = await response.json();  // API 요청 시 토큰 사용 fetch(\'/api/notices\', {   headers: { \'Authorization\': `Bearer ${idToken}` } }); ``` 
         * @summary 이메일/비밀번호 로그인 (간편)
         * @param {EmailLoginRequest} emailLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginWithEmail(emailLoginRequest: EmailLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithEmail(emailLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.loginWithEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그아웃 처리를 합니다. Firebase SDK에서 auth().signOut()을 호출하세요.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Firebase 이메일 인증 메일을 재발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript const user = auth().currentUser; await user.sendEmailVerification(); ```  이미 발송된 인증 메일을 받지 못한 경우 재발송합니다. 
         * @summary 이메일 인증 메일 재발송 (Firebase)
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVerificationEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVerificationEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
         * @summary 최근 검색어 저장
         * @param {SaveRequest} saveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRecentSearch(saveRequest: SaveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRecentSearch(saveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.saveRecentSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * PostgreSQL Full-Text Search를 사용한 고속 검색 기능입니다.  **검색 기능:** - 제목 및 내용에서 키워드 검색 - 여러 단어 입력 시 OR 검색 (예: \"장학금 학사\" → 장학금 OR 학사) - 검색어 하이라이트 (<mark> 태그) - 관련도 점수 기반 정렬 (ts_rank)  **정렬 옵션:** - relevance: 관련도순 (기본값) - 검색어와 가장 관련있는 순서 - latest: 최신순 - 게시일 기준 최신 - oldest: 오래된순 - 게시일 기준 오래된  **성능:** - GIN 인덱스 사용으로 LIKE 검색 대비 10-100배 빠름 - 10,000건 기준: LIKE 200ms vs FTS 5ms 
         * @summary 공지사항 전문 검색
         * @param {string} keyword 검색 키워드 (필수)
         * @param {number} [categoryId] 카테고리 ID 필터 (선택사항)
         * @param {string} [sortBy] 정렬 방식 (relevance, latest, oldest)
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지 크기
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(keyword: string, categoryId?: number, sortBy?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(keyword, categoryId, sortBy, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Firebase 이메일 인증 링크를 생성하여 발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript // React Native await user.sendEmailVerification();  // React Web import { sendEmailVerification } from \'firebase/auth\'; await sendEmailVerification(user); ```  **이 API 사용 시:** - 서버에서 커스텀 이메일 템플릿 사용 가능 - 이메일 발송을 서버에서 완전히 제어  Firebase 회원가입 후 이메일이 인증되지 않은 사용자에게 인증 메일을 발송합니다. 
         * @summary 이메일 인증 메일 발송 (Firebase)
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendVerificationEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendVerificationEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 서버에서 Firebase Authentication에 사용자를 생성하고 DB에 저장합니다.  **플로우:** 1. **회원가입 API 호출** (이 엔드포인트)    - 서버: Firebase에 사용자 생성 + DB 저장    - 서버: 이메일 인증 링크 발송  2. **클라이언트: Firebase 로그인**    ```javascript    // React Native 예시    import auth from \'@react-native-firebase/auth\';     const userCredential = await auth().signInWithEmailAndPassword(email, password);    const idToken = await userCredential.user.getIdToken();    ```  3. **클라이언트: FCM 토큰 발급**    ```javascript    import messaging from \'@react-native-firebase/messaging\';     const fcmToken = await messaging().getToken();    ```  4. **로그인 API 호출** (`POST /api/auth/login`)    ```json    {      \"idToken\": \"eyJhbGc...\",      \"fcmToken\": \"dW4f2...\"    }    ```  **중요:** - ⚠️ idToken과 fcmToken은 서버에서 발급할 수 없습니다 - ⚠️ 회원가입 후 반드시 위 2-4 단계를 진행해야 합니다 - 이메일 인증은 선택사항 (인증 전에도 로그인 가능)  **대안 방법 (클라이언트 우선):** 1. 클라이언트: Firebase SDK로 직접 회원가입 `createUserWithEmailAndPassword()` 2. 클라이언트: ID Token 발급 3. 서버: `/api/auth/login` 호출 시 자동으로 DB에 사용자 생성 
         * @summary 회원가입 (Firebase 통합)
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
         * @summary 카테고리 구독
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeCategory(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeCategory(subscribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.subscribeCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 카테고리 구독을 취소합니다.
         * @summary 구독 취소
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeCategory(categoryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsubscribeCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 저장한 북마크의 메모를 수정합니다.
         * @summary 북마크 메모 수정
         * @param {number} id 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBookmarkMemo(id: number, updateRequest: UpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBookmarkMemo(id, updateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateBookmarkMemo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
         * @summary FCM 토큰 업데이트
         * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFcmToken(updateFcmTokenRequest: UpdateFcmTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFcmToken(updateFcmTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateFcmToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
         * @summary 알림 설정 변경
         * @param {number} categoryId 
         * @param {UpdateNotificationRequest} updateNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(categoryId, updateNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자의 이름 등 프로필 정보를 수정합니다.
         * @summary 프로필 수정
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(updateProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
         * @summary 사용자 설정 수정
         * @param {UpdateSettingsRequest} updateSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSettings(updateSettingsRequest: UpdateSettingsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSettings(updateSettingsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 입력 중인 검색어에 대한 자동완성 제안을 제공합니다.  - 최소 2글자 이상 입력 필요 - 접두사 매칭 (prefix matching) - 매칭된 공지사항 수와 함께 반환 
         * @summary 검색어 자동완성
         * @param {string} prefix 검색어 접두사 (최소 2글자)
         * @param {number} [limit] 결과 개수 제한
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocomplete(prefix: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListAutocompleteSuggestion> {
            return localVarFp.autocomplete(prefix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
         * @summary 비밀번호 변경
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
         * @summary 북마크 생성
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark(createRequest: CreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.createBookmark(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
         * @summary 회원 탈퇴
         * @param {DeleteAccountRequest} deleteAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(deleteAccountRequest: DeleteAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.deleteAccount(deleteAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자의 모든 최근 검색어를 삭제합니다.
         * @summary 모든 최근 검색어 삭제
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllRecentSearches(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.deleteAllRecentSearches(options).then((request) => request(axios, basePath));
        },
        /**
         * 저장한 북마크를 삭제합니다.
         * @summary 북마크 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmark(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.deleteBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 최근 검색어를 삭제합니다.
         * @summary 최근 검색어 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecentSearch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.deleteRecentSearch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
         * @summary 아이디 찾기
         * @param {FindIdRequest} findIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findId(findIdRequest: FindIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseFindIdResponse> {
            return localVarFp.findId(findIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 비밀번호를 잊어버린 사용자에게 재설정 이메일을 발송합니다.  **Firebase 기반:** - Firebase Admin SDK로 비밀번호 재설정 링크 생성 - 이메일로 재설정 링크 발송 - 사용자는 링크를 클릭하여 새 비밀번호 설정  **사용 방법:** 1. 이메일 입력하여 요청 2. 이메일로 재설정 링크 수신 3. 링크 클릭하여 새 비밀번호 입력 4. Firebase에서 자동으로 비밀번호 업데이트  **제한:** - 동일 이메일로 1시간에 최대 3회까지 요청 가능 
         * @summary 비밀번호 재설정 요청
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.forgotPassword(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 활성 상태인 카테고리만 조회합니다.
         * @summary 활성 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCategories(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getActiveCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 알림이 활성화된 구독 카테고리만 조회합니다.
         * @summary 활성 구독 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePreferences(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getActivePreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
         * @summary 전체 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getAllCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 북마크의 상세 정보를 조회합니다.
         * @summary 북마크 상세 조회
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.getBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 저장한 북마크의 총 개수를 조회합니다.
         * @summary 북마크 개수 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkCount(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseLong> {
            return localVarFp.getBookmarkCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
         * @summary 특정 카테고리 조회
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryByCode(code: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.getCategoryByCode(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 중요 표시된 공지사항 목록을 조회합니다.
         * @summary 중요 공지사항 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportantNotices(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getImportantNotices(options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
         * @summary 북마크 목록 조회
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyBookmarks(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponsePageResponse> {
            return localVarFp.getMyBookmarks(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 현재 로그인한 사용자의 정보를 조회합니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.getMyInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 구독한 모든 카테고리 목록을 조회합니다.
         * @summary 구독 카테고리 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPreferences(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getMyPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 공지사항의 상세 정보를 조회합니다. 조회 시 조회수가 1 증가합니다.
         * @summary 공지사항 상세 조회
         * @param {number} noticeId 공지사항 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeDetail(noticeId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDetailResponse> {
            return localVarFp.getNoticeDetail(noticeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 공지사항 목록을 페이징하여 조회합니다. 카테고리, 중요 공지 필터링과 정렬 옵션을 제공합니다.
         * @summary 공지사항 목록 조회
         * @param {number} [categoryId] 카테고리 ID (선택사항)
         * @param {string} [sortBy] 정렬 방식 (latest: 최신순, oldest: 오래된순, popular: 인기순)
         * @param {boolean} [important] 중요 공지만 조회 여부
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지 크기
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotices(categoryId?: number, sortBy?: string, important?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponsePageResponse> {
            return localVarFp.getNotices(categoryId, sortBy, important, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 최근 24시간 기준 인기 검색어 TOP N을 조회합니다.  **Note:** 현재는 구현되지 않았습니다. search_log 테이블 추가 후 활성화됩니다. 
         * @summary 인기 검색어 조회
         * @param {number} [limit] 조회할 인기 검색어 개수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularKeywords(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListPopularKeyword> {
            return localVarFp.getPopularKeywords(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
         * @summary 최근 검색어 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentSearches(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getRecentSearches(options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 공지사항과 같은 카테고리의 다른 공지사항을 조회합니다.
         * @summary 관련 공지사항 조회
         * @param {number} noticeId 기준 공지사항 ID
         * @param {number} [limit] 조회할 관련 공지사항 개수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedNotices(noticeId: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getRelatedNotices(noticeId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 크롤러 서버에서 새 공지사항 등록 시 호출됩니다.  **동작 과정:** 1. 크롤러가 새 공지사항 발견 및 DB 저장 2. 이 웹훅 호출 (POST /api/webhook/new-notice) 3. 키워드 매칭 검사 4. 매칭된 사용자들에게 FCM 푸시 알림 발송  **보안:** - API Key 인증 필요 (X-API-Key 헤더) - 크롤러 서버만 호출 가능  **제한:** - Rate limit: 1000 requests/hour 
         * @summary 새 공지사항 등록 웹훅
         * @param {NewNoticeWebhookRequest} newNoticeWebhookRequest 
         * @param {string} [xAPIKey] 크롤러 API Key (헤더)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNewNotice(newNoticeWebhookRequest: NewNoticeWebhookRequest, xAPIKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseWebhookResponse> {
            return localVarFp.handleNewNotice(newNoticeWebhookRequest, xAPIKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 웹훅 서비스 상태 확인
         * @summary 웹훅 헬스체크
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 공지사항이 북마크되어 있는지 확인합니다.
         * @summary 북마크 여부 확인
         * @param {number} noticeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isBookmarked(noticeId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseBoolean> {
            return localVarFp.isBookmarked(noticeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 카테고리를 구독하고 있는지 확인합니다.
         * @summary 구독 여부 확인
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isSubscribed(categoryId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseBoolean> {
            return localVarFp.isSubscribed(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Firebase ID Token을 사용하여 로그인합니다.  **사용 방법:** 1. 클라이언트에서 Firebase SDK로 로그인    - 이메일/비밀번호: `signInWithEmailAndPassword(email, password)`    - Google: `signInWithPopup(googleProvider)`    - 기타 소셜 로그인 2. Firebase ID Token 발급: `user.getIdToken()` 3. 이 API에 ID Token 전송 4. 서버에서 토큰 검증 및 사용자 정보 동기화  **자동 회원가입:** Firebase로 로그인한 사용자가 서버 DB에 없는 경우, 자동으로 사용자가 생성됩니다.  **토큰 갱신:** Firebase SDK가 자동으로 처리합니다. `user.getIdToken(true)`를 호출하세요. 
         * @summary 로그인 (Firebase Authentication)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseLoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일과 비밀번호로 간편하게 로그인합니다.  **사용법:** ```bash POST /api/auth/login/email {   \"email\": \"test@inu.ac.kr\",   \"password\": \"password123\",   \"fcmToken\": \"dW4f2...\" (선택사항) } ```  **응답:** ```json {   \"success\": true,   \"data\": {     \"idToken\": \"eyJhbGc...\",  // Firebase 커스텀 토큰     \"tokenType\": \"Bearer\",     \"expiresIn\": 3600,     \"user\": {       \"id\": 1,       \"email\": \"test@inu.ac.kr\",       \"name\": \"홍길동\"     }   } } ```  **주의:** - ✅ 회원가입 직후 바로 사용 가능 - ✅ Firebase SDK 없이도 로그인 가능 - ⚠️ idToken(커스텀 토큰)은 Firebase 로그인 시에만 사용 - 💡 API 인증에는 이 토큰을 그대로 사용하세요  **클라이언트 사용 예시:** ```javascript const response = await fetch(\'/api/auth/login/email\', {   method: \'POST\',   headers: { \'Content-Type\': \'application/json\' },   body: JSON.stringify({     email: \'test@inu.ac.kr\',     password: \'password123\'   }) });  const { idToken, user } = await response.json();  // API 요청 시 토큰 사용 fetch(\'/api/notices\', {   headers: { \'Authorization\': `Bearer ${idToken}` } }); ``` 
         * @summary 이메일/비밀번호 로그인 (간편)
         * @param {EmailLoginRequest} emailLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithEmail(emailLoginRequest: EmailLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseLoginResponse> {
            return localVarFp.loginWithEmail(emailLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그아웃 처리를 합니다. Firebase SDK에서 auth().signOut()을 호출하세요.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Firebase 이메일 인증 메일을 재발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript const user = auth().currentUser; await user.sendEmailVerification(); ```  이미 발송된 인증 메일을 받지 못한 경우 재발송합니다. 
         * @summary 이메일 인증 메일 재발송 (Firebase)
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationEmail(email: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.resendVerificationEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
         * @summary 최근 검색어 저장
         * @param {SaveRequest} saveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRecentSearch(saveRequest: SaveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.saveRecentSearch(saveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * PostgreSQL Full-Text Search를 사용한 고속 검색 기능입니다.  **검색 기능:** - 제목 및 내용에서 키워드 검색 - 여러 단어 입력 시 OR 검색 (예: \"장학금 학사\" → 장학금 OR 학사) - 검색어 하이라이트 (<mark> 태그) - 관련도 점수 기반 정렬 (ts_rank)  **정렬 옵션:** - relevance: 관련도순 (기본값) - 검색어와 가장 관련있는 순서 - latest: 최신순 - 게시일 기준 최신 - oldest: 오래된순 - 게시일 기준 오래된  **성능:** - GIN 인덱스 사용으로 LIKE 검색 대비 10-100배 빠름 - 10,000건 기준: LIKE 200ms vs FTS 5ms 
         * @summary 공지사항 전문 검색
         * @param {string} keyword 검색 키워드 (필수)
         * @param {number} [categoryId] 카테고리 ID 필터 (선택사항)
         * @param {string} [sortBy] 정렬 방식 (relevance, latest, oldest)
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지 크기
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(keyword: string, categoryId?: number, sortBy?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseSearchResponse> {
            return localVarFp.search(keyword, categoryId, sortBy, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Firebase 이메일 인증 링크를 생성하여 발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript // React Native await user.sendEmailVerification();  // React Web import { sendEmailVerification } from \'firebase/auth\'; await sendEmailVerification(user); ```  **이 API 사용 시:** - 서버에서 커스텀 이메일 템플릿 사용 가능 - 이메일 발송을 서버에서 완전히 제어  Firebase 회원가입 후 이메일이 인증되지 않은 사용자에게 인증 메일을 발송합니다. 
         * @summary 이메일 인증 메일 발송 (Firebase)
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationEmail(email: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.sendVerificationEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 서버에서 Firebase Authentication에 사용자를 생성하고 DB에 저장합니다.  **플로우:** 1. **회원가입 API 호출** (이 엔드포인트)    - 서버: Firebase에 사용자 생성 + DB 저장    - 서버: 이메일 인증 링크 발송  2. **클라이언트: Firebase 로그인**    ```javascript    // React Native 예시    import auth from \'@react-native-firebase/auth\';     const userCredential = await auth().signInWithEmailAndPassword(email, password);    const idToken = await userCredential.user.getIdToken();    ```  3. **클라이언트: FCM 토큰 발급**    ```javascript    import messaging from \'@react-native-firebase/messaging\';     const fcmToken = await messaging().getToken();    ```  4. **로그인 API 호출** (`POST /api/auth/login`)    ```json    {      \"idToken\": \"eyJhbGc...\",      \"fcmToken\": \"dW4f2...\"    }    ```  **중요:** - ⚠️ idToken과 fcmToken은 서버에서 발급할 수 없습니다 - ⚠️ 회원가입 후 반드시 위 2-4 단계를 진행해야 합니다 - 이메일 인증은 선택사항 (인증 전에도 로그인 가능)  **대안 방법 (클라이언트 우선):** 1. 클라이언트: Firebase SDK로 직접 회원가입 `createUserWithEmailAndPassword()` 2. 클라이언트: ID Token 발급 3. 서버: `/api/auth/login` 호출 시 자동으로 DB에 사용자 생성 
         * @summary 회원가입 (Firebase 통합)
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseUserResponse> {
            return localVarFp.signUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
         * @summary 카테고리 구독
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCategory(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.subscribeCategory(subscribeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 카테고리 구독을 취소합니다.
         * @summary 구독 취소
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeCategory(categoryId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.unsubscribeCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 저장한 북마크의 메모를 수정합니다.
         * @summary 북마크 메모 수정
         * @param {number} id 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkMemo(id: number, updateRequest: UpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateBookmarkMemo(id, updateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
         * @summary FCM 토큰 업데이트
         * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFcmToken(updateFcmTokenRequest: UpdateFcmTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.updateFcmToken(updateFcmTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
         * @summary 알림 설정 변경
         * @param {number} categoryId 
         * @param {UpdateNotificationRequest} updateNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateNotification(categoryId, updateNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자의 이름 등 프로필 정보를 수정합니다.
         * @summary 프로필 수정
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateProfile(updateProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
         * @summary 사용자 설정 수정
         * @param {UpdateSettingsRequest} updateSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings(updateSettingsRequest: UpdateSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateSettings(updateSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 입력 중인 검색어에 대한 자동완성 제안을 제공합니다.  - 최소 2글자 이상 입력 필요 - 접두사 매칭 (prefix matching) - 매칭된 공지사항 수와 함께 반환 
     * @summary 검색어 자동완성
     * @param {string} prefix 검색어 접두사 (최소 2글자)
     * @param {number} [limit] 결과 개수 제한
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public autocomplete(prefix: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).autocomplete(prefix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
     * @summary 비밀번호 변경
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
     * @summary 북마크 생성
     * @param {CreateRequest} createRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBookmark(createRequest: CreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBookmark(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
     * @summary 회원 탈퇴
     * @param {DeleteAccountRequest} deleteAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAccount(deleteAccountRequest: DeleteAccountRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAccount(deleteAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자의 모든 최근 검색어를 삭제합니다.
     * @summary 모든 최근 검색어 삭제
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAllRecentSearches(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAllRecentSearches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 저장한 북마크를 삭제합니다.
     * @summary 북마크 삭제
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteBookmark(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 최근 검색어를 삭제합니다.
     * @summary 최근 검색어 삭제
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRecentSearch(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteRecentSearch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
     * @summary 아이디 찾기
     * @param {FindIdRequest} findIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findId(findIdRequest: FindIdRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findId(findIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 비밀번호를 잊어버린 사용자에게 재설정 이메일을 발송합니다.  **Firebase 기반:** - Firebase Admin SDK로 비밀번호 재설정 링크 생성 - 이메일로 재설정 링크 발송 - 사용자는 링크를 클릭하여 새 비밀번호 설정  **사용 방법:** 1. 이메일 입력하여 요청 2. 이메일로 재설정 링크 수신 3. 링크 클릭하여 새 비밀번호 입력 4. Firebase에서 자동으로 비밀번호 업데이트  **제한:** - 동일 이메일로 1시간에 최대 3회까지 요청 가능 
     * @summary 비밀번호 재설정 요청
     * @param {ForgotPasswordRequest} forgotPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forgotPassword(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 활성 상태인 카테고리만 조회합니다.
     * @summary 활성 카테고리 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActiveCategories(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActiveCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 알림이 활성화된 구독 카테고리만 조회합니다.
     * @summary 활성 구독 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActivePreferences(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActivePreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
     * @summary 전체 카테고리 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllCategories(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 북마크의 상세 정보를 조회합니다.
     * @summary 북마크 상세 조회
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBookmark(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 저장한 북마크의 총 개수를 조회합니다.
     * @summary 북마크 개수 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBookmarkCount(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBookmarkCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
     * @summary 특정 카테고리 조회
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCategoryByCode(code: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCategoryByCode(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 중요 표시된 공지사항 목록을 조회합니다.
     * @summary 중요 공지사항 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getImportantNotices(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getImportantNotices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
     * @summary 북마크 목록 조회
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyBookmarks(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyBookmarks(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 현재 로그인한 사용자의 정보를 조회합니다.
     * @summary 내 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyInfo(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 구독한 모든 카테고리 목록을 조회합니다.
     * @summary 구독 카테고리 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyPreferences(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 공지사항의 상세 정보를 조회합니다. 조회 시 조회수가 1 증가합니다.
     * @summary 공지사항 상세 조회
     * @param {number} noticeId 공지사항 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNoticeDetail(noticeId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNoticeDetail(noticeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 공지사항 목록을 페이징하여 조회합니다. 카테고리, 중요 공지 필터링과 정렬 옵션을 제공합니다.
     * @summary 공지사항 목록 조회
     * @param {number} [categoryId] 카테고리 ID (선택사항)
     * @param {string} [sortBy] 정렬 방식 (latest: 최신순, oldest: 오래된순, popular: 인기순)
     * @param {boolean} [important] 중요 공지만 조회 여부
     * @param {number} [page] 페이지 번호 (0부터 시작)
     * @param {number} [size] 페이지 크기
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNotices(categoryId?: number, sortBy?: string, important?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNotices(categoryId, sortBy, important, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 최근 24시간 기준 인기 검색어 TOP N을 조회합니다.  **Note:** 현재는 구현되지 않았습니다. search_log 테이블 추가 후 활성화됩니다. 
     * @summary 인기 검색어 조회
     * @param {number} [limit] 조회할 인기 검색어 개수
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPopularKeywords(limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPopularKeywords(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
     * @summary 최근 검색어 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRecentSearches(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentSearches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 공지사항과 같은 카테고리의 다른 공지사항을 조회합니다.
     * @summary 관련 공지사항 조회
     * @param {number} noticeId 기준 공지사항 ID
     * @param {number} [limit] 조회할 관련 공지사항 개수
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRelatedNotices(noticeId: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRelatedNotices(noticeId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 크롤러 서버에서 새 공지사항 등록 시 호출됩니다.  **동작 과정:** 1. 크롤러가 새 공지사항 발견 및 DB 저장 2. 이 웹훅 호출 (POST /api/webhook/new-notice) 3. 키워드 매칭 검사 4. 매칭된 사용자들에게 FCM 푸시 알림 발송  **보안:** - API Key 인증 필요 (X-API-Key 헤더) - 크롤러 서버만 호출 가능  **제한:** - Rate limit: 1000 requests/hour 
     * @summary 새 공지사항 등록 웹훅
     * @param {NewNoticeWebhookRequest} newNoticeWebhookRequest 
     * @param {string} [xAPIKey] 크롤러 API Key (헤더)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleNewNotice(newNoticeWebhookRequest: NewNoticeWebhookRequest, xAPIKey?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).handleNewNotice(newNoticeWebhookRequest, xAPIKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 웹훅 서비스 상태 확인
     * @summary 웹훅 헬스체크
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public health(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 공지사항이 북마크되어 있는지 확인합니다.
     * @summary 북마크 여부 확인
     * @param {number} noticeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public isBookmarked(noticeId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isBookmarked(noticeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 카테고리를 구독하고 있는지 확인합니다.
     * @summary 구독 여부 확인
     * @param {number} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public isSubscribed(categoryId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isSubscribed(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Firebase ID Token을 사용하여 로그인합니다.  **사용 방법:** 1. 클라이언트에서 Firebase SDK로 로그인    - 이메일/비밀번호: `signInWithEmailAndPassword(email, password)`    - Google: `signInWithPopup(googleProvider)`    - 기타 소셜 로그인 2. Firebase ID Token 발급: `user.getIdToken()` 3. 이 API에 ID Token 전송 4. 서버에서 토큰 검증 및 사용자 정보 동기화  **자동 회원가입:** Firebase로 로그인한 사용자가 서버 DB에 없는 경우, 자동으로 사용자가 생성됩니다.  **토큰 갱신:** Firebase SDK가 자동으로 처리합니다. `user.getIdToken(true)`를 호출하세요. 
     * @summary 로그인 (Firebase Authentication)
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일과 비밀번호로 간편하게 로그인합니다.  **사용법:** ```bash POST /api/auth/login/email {   \"email\": \"test@inu.ac.kr\",   \"password\": \"password123\",   \"fcmToken\": \"dW4f2...\" (선택사항) } ```  **응답:** ```json {   \"success\": true,   \"data\": {     \"idToken\": \"eyJhbGc...\",  // Firebase 커스텀 토큰     \"tokenType\": \"Bearer\",     \"expiresIn\": 3600,     \"user\": {       \"id\": 1,       \"email\": \"test@inu.ac.kr\",       \"name\": \"홍길동\"     }   } } ```  **주의:** - ✅ 회원가입 직후 바로 사용 가능 - ✅ Firebase SDK 없이도 로그인 가능 - ⚠️ idToken(커스텀 토큰)은 Firebase 로그인 시에만 사용 - 💡 API 인증에는 이 토큰을 그대로 사용하세요  **클라이언트 사용 예시:** ```javascript const response = await fetch(\'/api/auth/login/email\', {   method: \'POST\',   headers: { \'Content-Type\': \'application/json\' },   body: JSON.stringify({     email: \'test@inu.ac.kr\',     password: \'password123\'   }) });  const { idToken, user } = await response.json();  // API 요청 시 토큰 사용 fetch(\'/api/notices\', {   headers: { \'Authorization\': `Bearer ${idToken}` } }); ``` 
     * @summary 이메일/비밀번호 로그인 (간편)
     * @param {EmailLoginRequest} emailLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginWithEmail(emailLoginRequest: EmailLoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginWithEmail(emailLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그아웃 처리를 합니다. Firebase SDK에서 auth().signOut()을 호출하세요.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Firebase 이메일 인증 메일을 재발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript const user = auth().currentUser; await user.sendEmailVerification(); ```  이미 발송된 인증 메일을 받지 못한 경우 재발송합니다. 
     * @summary 이메일 인증 메일 재발송 (Firebase)
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendVerificationEmail(email: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resendVerificationEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
     * @summary 최근 검색어 저장
     * @param {SaveRequest} saveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public saveRecentSearch(saveRequest: SaveRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).saveRecentSearch(saveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PostgreSQL Full-Text Search를 사용한 고속 검색 기능입니다.  **검색 기능:** - 제목 및 내용에서 키워드 검색 - 여러 단어 입력 시 OR 검색 (예: \"장학금 학사\" → 장학금 OR 학사) - 검색어 하이라이트 (<mark> 태그) - 관련도 점수 기반 정렬 (ts_rank)  **정렬 옵션:** - relevance: 관련도순 (기본값) - 검색어와 가장 관련있는 순서 - latest: 최신순 - 게시일 기준 최신 - oldest: 오래된순 - 게시일 기준 오래된  **성능:** - GIN 인덱스 사용으로 LIKE 검색 대비 10-100배 빠름 - 10,000건 기준: LIKE 200ms vs FTS 5ms 
     * @summary 공지사항 전문 검색
     * @param {string} keyword 검색 키워드 (필수)
     * @param {number} [categoryId] 카테고리 ID 필터 (선택사항)
     * @param {string} [sortBy] 정렬 방식 (relevance, latest, oldest)
     * @param {number} [page] 페이지 번호 (0부터 시작)
     * @param {number} [size] 페이지 크기
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public search(keyword: string, categoryId?: number, sortBy?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).search(keyword, categoryId, sortBy, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Firebase 이메일 인증 링크를 생성하여 발송합니다.  **⚠️ 권장 방법 (클라이언트):** ```javascript // React Native await user.sendEmailVerification();  // React Web import { sendEmailVerification } from \'firebase/auth\'; await sendEmailVerification(user); ```  **이 API 사용 시:** - 서버에서 커스텀 이메일 템플릿 사용 가능 - 이메일 발송을 서버에서 완전히 제어  Firebase 회원가입 후 이메일이 인증되지 않은 사용자에게 인증 메일을 발송합니다. 
     * @summary 이메일 인증 메일 발송 (Firebase)
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendVerificationEmail(email: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sendVerificationEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 서버에서 Firebase Authentication에 사용자를 생성하고 DB에 저장합니다.  **플로우:** 1. **회원가입 API 호출** (이 엔드포인트)    - 서버: Firebase에 사용자 생성 + DB 저장    - 서버: 이메일 인증 링크 발송  2. **클라이언트: Firebase 로그인**    ```javascript    // React Native 예시    import auth from \'@react-native-firebase/auth\';     const userCredential = await auth().signInWithEmailAndPassword(email, password);    const idToken = await userCredential.user.getIdToken();    ```  3. **클라이언트: FCM 토큰 발급**    ```javascript    import messaging from \'@react-native-firebase/messaging\';     const fcmToken = await messaging().getToken();    ```  4. **로그인 API 호출** (`POST /api/auth/login`)    ```json    {      \"idToken\": \"eyJhbGc...\",      \"fcmToken\": \"dW4f2...\"    }    ```  **중요:** - ⚠️ idToken과 fcmToken은 서버에서 발급할 수 없습니다 - ⚠️ 회원가입 후 반드시 위 2-4 단계를 진행해야 합니다 - 이메일 인증은 선택사항 (인증 전에도 로그인 가능)  **대안 방법 (클라이언트 우선):** 1. 클라이언트: Firebase SDK로 직접 회원가입 `createUserWithEmailAndPassword()` 2. 클라이언트: ID Token 발급 3. 서버: `/api/auth/login` 호출 시 자동으로 DB에 사용자 생성 
     * @summary 회원가입 (Firebase 통합)
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
     * @summary 카테고리 구독
     * @param {SubscribeRequest} subscribeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public subscribeCategory(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscribeCategory(subscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 카테고리 구독을 취소합니다.
     * @summary 구독 취소
     * @param {number} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unsubscribeCategory(categoryId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsubscribeCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 저장한 북마크의 메모를 수정합니다.
     * @summary 북마크 메모 수정
     * @param {number} id 
     * @param {UpdateRequest} updateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateBookmarkMemo(id: number, updateRequest: UpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateBookmarkMemo(id, updateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
     * @summary FCM 토큰 업데이트
     * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFcmToken(updateFcmTokenRequest: UpdateFcmTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateFcmToken(updateFcmTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
     * @summary 알림 설정 변경
     * @param {number} categoryId 
     * @param {UpdateNotificationRequest} updateNotificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateNotification(categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateNotification(categoryId, updateNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자의 이름 등 프로필 정보를 수정합니다.
     * @summary 프로필 수정
     * @param {UpdateProfileRequest} updateProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProfile(updateProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
     * @summary 사용자 설정 수정
     * @param {UpdateSettingsRequest} updateSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSettings(updateSettingsRequest: UpdateSettingsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateSettings(updateSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestControllerApi - axios parameter creator
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelloMessage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hello`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelloMessage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelloMessage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.getHelloMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestControllerApi - factory interface
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelloMessage(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getHelloMessage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHelloMessage(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).getHelloMessage(options).then((request) => request(this.axios, this.basePath));
    }
}



